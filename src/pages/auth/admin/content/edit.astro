---
import '$lib/styles/editor.scss'
import BaseLayout from '$layouts/Base.astro'

import { WlDatabase } from '@webslab/shared/components/database';

import HeroPicker from '$components/admin/content/edit/HeroPicker.astro'
import Template from '$components/admin/content/edit/Template.astro'
import Modal from '$components/admin/content/edit/Modal.astro'
---

<BaseLayout
  auth={true}
  admin={true}
  title="Content editor"
  description="Posts Editor for the Blog"
  back={{enabled: true}}>

  <div slot="actions">
    <button
      id="save"
      type="submit"
      class="btn btn-primary">Save</button>
  </div>

  <WlDatabase
    live={false}
    target="section"
    query=""
    client:only="lit">
    <div>
      <section></section>
    </div>

    <Template />
    <HeroPicker class="d-none" id="foo" inputId="hero"/>

    <script>
      import { initWlDatabase } from '$lib/utils'

      const postId = new URLSearchParams(window.location.search).get('id')
      const query = `SELECT time::format(publish, '%Y-%m-%d') as publish_fmt, author.name as authorName, * FROM ${postId};`

      initWlDatabase(query)
    </script>
  </WlDatabase>

  <Modal modalId="questionModal" />

  <!-- TOAST -->
<div class="toast-container position-fixed bottom-0 end-0 p-3">
  <div id="liveToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
    <div class="toast-header">
      <strong class="me-auto text-primary">Editor</strong>
      <small>Now</small>

      <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
    </div>

    <div class="toast-body">Content saved</div>

    <script>console.log('hello')</script>
  </div>
</div>
</BaseLayout>

<script>
  import { RecordId, StringRecordId } from "surrealdb";
  import Toast from "bootstrap/js/dist/toast";

  import { QuestionService } from "$lib/services/questions.ts";
  import { WEBSLAB_PROJECT, WEBSLAB_TOKEN } from "$lib/consts.ts";

  import { getWlDatabase } from "$lib/utils.ts";
  import { waitElement } from "$lib/utils.ts";
  import { authService } from "$lib/services/auth.ts";
  import { editor } from "$lib/services/editor.ts";

  import type { Question } from "$lib/types.ts";

  const postId = new URLSearchParams(window.location.search).get("id");
  let currentPage = 0;

  getWlDatabase().then(async (wlDatabase) => {
    import("$lib/hero.ts");

    wlDatabase.addEventListener("wl-task:completed", async (evt: CustomEvent) => {
      // Esperar a que todos los elementos críticos estén disponibles
      await waitElement("#post-content");
      await waitElement("#title");
      await waitElement("#author");
      await waitElement("#publish");

      const db = authService.getDb();

      const add = document.getElementById("add-page");
      const save = document.getElementById("save");
      const hero = document.getElementById("hero") as HTMLInputElement;
      const title = document.getElementById("title") as HTMLInputElement;
      const author = document.getElementById("author")?.dataset;
      const publish = document.getElementById("publish") as HTMLInputElement;
      const content = document.getElementById("post-content") as HTMLTextAreaElement;
      const tableName = document.getElementById("table-name");
      const pagesContainer = document.getElementById("pages-container");
      const toastLiveExample = document.getElementById("liveToast");

      // Verificar que todos los elementos críticos existan
      if (!content) {
        console.error("Required element post-content not found");
        return;
      }
      if (!hero || !title || !publish) {
        console.error("Required form elements not found");
        return;
      }

      // hero
      const foo = document.getElementById("foo");
      const heroPicker = document.getElementById("heroPicker");
      const heroPreview = document.getElementById("hero-preview") as HTMLImageElement;
      const heroCurrent = heroPicker?.dataset?.current;

      if (heroPreview && heroCurrent) {
        heroPreview.src = heroCurrent;
      }

      if (hero && heroCurrent) {
        hero.value = heroCurrent;
      }

      if (heroPicker && foo) {
        heroPicker.appendChild(foo);
        foo.classList.remove("d-none");
      }

      const questionsSvc = postId.startsWith("module")
        ? new QuestionService(db, "questionModal")
        : undefined;

      const jodit = editor.makeEditor(content, questionsSvc);

      if (!jodit) {
        console.error("Failed to create Jodit editor");
        return;
      }

      const table = evt.detail.result[0][0].id.tb;
      const pages = evt.detail.result[0][0].content;

      // tableName.innerText = table.charAt(0).toUpperCase() + table.slice(1)

      if (table === "module" && pagesContainer) {
        pagesList(pages);
        pagesContainer.classList.remove("d-none");

        // Inicializar delegación de eventos para botones de movimiento
        setupPageMoveListeners();
      }

      if (save) {
        save.addEventListener("click", savePost);
      }

      if (add) {
        add.addEventListener("click", () => {
          const pagesList = document.getElementById("pages-list");
          const item = document.createElement("li");

          item.classList.add("list-group-item");
          item.dataset.index = pages.length.toString();
          item.innerHTML = `
                <div class="d-flex align-items-center">
                  <!-- Botones de reordenamiento -->
                  <div class="btn-group-vertical me-2" role="group">
                    <button class="btn btn-sm btn-outline-secondary move-up"
                            style="line-height: 1; padding: 2px 6px; font-size: 10px;">
                      ↑
                    </button>
                    <button class="btn btn-sm btn-outline-secondary move-down"
                            style="line-height: 1; padding: 2px 6px; font-size: 10px;">
                      ↓
                    </button>
                  </div>

                  <!-- Contenido existente -->
                  <span class="btn btn-sm btn-outline-secondary flex-grow-1">
                    Page: ${pages.length + 1}
                  </span>

                  <!-- Botón eliminar (existente) -->
                  <button
                    id="del-page"
                    class="btn btn-sm btn-outline-danger ms-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
                      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8z"/>
                    </svg>
                  </button>
                </div>`;

          addItemListener(item, pages.length, pages);
          pagesList.insertBefore(item, add.parentNode);

          // Actualizar botones deshabilitados después de agregar
          updateMoveButtons();

          // Hacer click en el span de la nueva página
          const newPageSpan = item.querySelector("span") as HTMLElement;
          newPageSpan.click();
          savePost();
        });
      }

      async function savePost() {
        // Verificar que los elementos necesarios existan
        if (!hero || !title || !publish || !toastLiveExample) {
          console.error("Required elements not found for savePost");
          return;
        }

        let hasEditableQuestions = false;
        let hasUserTouched = false;

        const editorContent = jodit.currentPlace.editor;
        editorContent.querySelectorAll("wl-question[edit]").forEach((el) => {
          el.removeAttribute("edit");
          hasEditableQuestions = true;
        });

        editorContent.querySelectorAll("wl-question[usertouched]").forEach((el) => {
          el.removeAttribute("usertouched");
          hasUserTouched = true;
        });

        if (hasEditableQuestions || hasUserTouched) {
          console.log("Se detectaron y limpiaron parámetros en preguntas");
        }

        // Ahora guardar el contenido limpio
        pages[currentPage] = editorContent.innerHTML;

        const toastBootstrap = Toast.getOrCreateInstance(toastLiveExample);
        toastBootstrap.show();

        const post = {
          hero: hero.value,
          title: title.value,
          // author: new StringRecordId(author.author),
          content: pages,
          publish: new Date(publish.value),
        };

        db
          .query(
            "UPDATE type::record($id) MERGE $post;",
            { id: postId, post },
          )
          .then(console.log)
          .catch(console.error);
      }

      // Función específica para guardar sin modificar el array pages
      async function savePostDirect() {
        // Verificar que los elementos necesarios existan
        if (!hero || !title || !publish || !toastLiveExample) {
          console.error("Required elements not found for savePostDirect");
          return;
        }

        const toastBootstrap = Toast.getOrCreateInstance(toastLiveExample);
        toastBootstrap.show();

        const post = {
          hero: hero.value,
          title: title.value,
          // author: new StringRecordId(author.author),
          content: pages,
          publish: new Date(publish.value),
        };

        db
          .query(
            "UPDATE type::record($id) MERGE $post;",
            { id: postId, post },
          )
          .then(console.log)
          .catch(console.error);
      }

      // Funciones de reordenamiento de páginas
      function movePageUp(index: number) {
        if (index <= 0) return; // No puede subir la primera página
        swapPages(index, index - 1);
      }

      function movePageDown(index: number) {
        if (index >= pages.length - 1) return; // No puede bajar la última página
        swapPages(index, index + 1);
      }

      function swapPages(fromIndex: number, toIndex: number) {
        // 1. Guardar contenido actual si está editándose
        if (currentPage === fromIndex || currentPage === toIndex) {
          pages[currentPage] = jodit.currentPlace.editor.innerHTML;
        }

        // 2. Intercambiar en el array
        [pages[fromIndex], pages[toIndex]] = [pages[toIndex], pages[fromIndex]];

        // 3. Actualizar currentPage si es necesario
        if (currentPage === fromIndex) {
          currentPage = toIndex;
        } else if (currentPage === toIndex) {
          currentPage = fromIndex;
        }

        // 4. Regenerar UI
        rebuildPagesList();

        // 5. Guardar cambios
        savePostDirect();
      }

      // Inicializar delegación de eventos para botones de movimiento
      function setupPageMoveListeners() {
        const pagesList = document.getElementById("pages-list");

        // Event listener delegado para botones de movimiento
        pagesList.addEventListener("click", (e) => {
          const target = e.target as HTMLElement;

          if (target.classList.contains("move-up")) {
            e.stopPropagation();
            const item = target.closest("li[data-index]") as HTMLElement;
            const index = parseInt(item.dataset.index);
            movePageUp(index);
          } else if (target.classList.contains("move-down")) {
            e.stopPropagation();
            const item = target.closest("li[data-index]") as HTMLElement;
            const index = parseInt(item.dataset.index);
            movePageDown(index);
          }
        });
      }

      function rebuildPagesList() {
        const pagesList = document.getElementById("pages-list");
        const items = Array.from(
          pagesList.querySelectorAll("li[data-index]"),
        ) as HTMLElement[];

        // Solo actualizar data-index y labels (sin tocar event listeners)
        items.forEach((item, newIndex) => {
          item.dataset.index = newIndex.toString();
          const label = item.querySelector("span");
          if (label) {
            label.textContent = `Page: ${newIndex + 1}`;
          }

          // Actualizar estado activo
          const span = item.querySelector("span");
          if (span) {
            if (newIndex === currentPage) {
              span.classList.add("active");
            } else {
              span.classList.remove("active");
            }
          }
        });

        // Actualizar botones deshabilitados
        updateMoveButtons();

        // Actualizar editor con página actual
        jodit.currentPlace.editor.innerHTML = pages[currentPage] || "";
      }

      function updateMoveButtons() {
        const pagesList = document.getElementById("pages-list");
        if (!pagesList) return;

        const items = pagesList.querySelectorAll("li[data-index]");

        items.forEach((item, index) => {
          const upBtn = item.querySelector(".move-up") as HTMLButtonElement;
          const downBtn = item.querySelector(".move-down") as HTMLButtonElement;

          if (upBtn && downBtn) {
            // Deshabilitar ↑ en primera página
            upBtn.disabled = index === 0;
            upBtn.classList.toggle("opacity-50", index === 0);

            // Deshabilitar ↓ en última página
            downBtn.disabled = index === items.length - 1;
            downBtn.classList.toggle("opacity-50", index === items.length - 1);
          }
        });
      }

      function addItemListener(item: HTMLElement, index: number, pages: string[]) {
        const del = item.querySelector("#del-page");
        const span = item.querySelector("span");

        if (index === 0) {
          span.classList.add("active");
        }

        // Event listener para seleccionar página
        span.addEventListener("click", async () => {
          const hasChanged = jodit.currentPlace.editor.innerHTML !== pages[currentPage];
          const prev = pagesContainer.querySelector(".active");

          if (!pages[currentPage]) {
            pages[currentPage] = jodit.currentPlace.editor.innerHTML;
          }

          if (pages[currentPage] && hasChanged) {
            await savePost();
          }

          if (index === currentPage) return;

          // toggle active class
          prev?.classList.remove("active");
          span.classList.add("active");

          jodit.currentPlace.editor.innerHTML = pages[index] || "";
          currentPage = parseInt(item.dataset.index);
        });

        // Event listener para eliminar página
        del.addEventListener("click", async (evt) => {
          if (index === 0) {
            alert("you cannot delete the first page");
            return;
          }

          if (index !== currentPage) {
            alert("you cannot delete a page that is not the current page");
            return;
          }

          pages.splice(index, 1);
          const pagesList = document.getElementById("pages-list");

          pagesList.removeChild(item);
          await savePostDirect();
          // await db.merge(new StringRecordId(postId), { content: pages });

          jodit.currentPlace.editor.innerHTML = pages[--currentPage] || "";

          const prev = pagesList.children[currentPage].querySelector(
            "span",
          ) as HTMLElement;

          setTimeout(() => {
            prev.click();
            prev.classList.add("active");

            setTimeout(() => {
              prev.classList.remove("active");
            }, 400);
          }, 100);
        });

        // Los event listeners de movimiento ahora están delegados
        // No necesitamos agregarlos aquí
      }

      function pagesList(pages: string[]) {
        const pagesList = document.getElementById("pages-list");
        const items = pagesList.querySelectorAll("li");

        items.forEach((item, index) => {
          if (item.dataset.index) addItemListener(item, index, pages);
        });

        // Inicializar estado de botones de movimiento
        updateMoveButtons();
      }
    });
  });
</script>

<script>
  import '@webslab/shared/components/question'
</script>
